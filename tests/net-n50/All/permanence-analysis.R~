############################################################################
# It reads a .G graph file, and returns the contents as a data frame object.
#
# network.path: the file path which stores the .G graph file
#
############################################################################
read.graph.ils.file.as.df = function(network.path){
	# skip the first line bc it does not contain graph info
	df = read.table(
			file=network.path, 
			header=FALSE, 
			sep="\t", 
			skip=1, 
			check.names=FALSE
	)
	# df$V1: vertex1
	# df$V2: vertex2
	# df$V3: weight
	return(df)
}



############################################################################
#  It reads a .G graph file, and returns the contents as a igraph graph object.
#  To handle isolated nodes, first we had to find the max vertex id.
#  Then, indicate explicitely vertices ids in graph.data.frame()
#
# network.path: the file path which stores the .G graph file
#
############################################################################
read.graph.ils = function(network.path){
	df = read.graph.ils.file.as.df(network.path)
	
	edg.list = df[,c(1, 2)]
	max.v.id = max(unique(c(edg.list[,1], edg.list[,2])))
	
	g <- graph.data.frame(edg.list, vertices=seq(0,max.v.id), directed=FALSE)
	cat("max id: ",max.v.id, "\n")
	E(g)$weight = df[, 3]
	# V(g)$id = seq(0,max.v.id)
	# V(g)$id = seq(1,max.v.id+1)
	
	return(g)
}

###########################################
# A: adjacency matrix created from the subgraph induced from the cluster of the vertex
# v.id : node id (vertex ids start from 1 => for adjacency matrix)
###########################################
compute.signed.clu.coef.in.cluster = function(A, v.id){
    coef = 0
    #cat("node: ", v.id, "\n")
    str.v.id = as.character(v.id)
    neig.indexs = which(A[str.v.id,] != 0)
    str.neig.ids = names(neig.indexs)
    nb.neig = length(str.neig.ids)
    #print(nb.neig)
    nominator = 0
    denominator = 0
    if(nb.neig>1){
        for(i in 1:(nb.neig-1)){
            neig.id1 = str.neig.ids[i]
      
            for(j in (i+1):nb.neig){
                 neig.id2 = str.neig.ids[j]
                 nominator = nominator + A[str.v.id,neig.id1]*A[str.v.id,neig.id2]*A[neig.id1,neig.id2]
                 denominator = denominator + abs(A[str.v.id,neig.id1]*A[str.v.id,neig.id2])
            }
            
        }
        coef = (nominator/denominator)
    }
    #cat("coef: ", coef, "\n")
    return(coef)
}




###########################################
#
###########################################
compute.mapping.for.external.coef = function(Emax.vec){
    Emax.vec2 = Emax.vec   
    zero.indx = which(Emax.vec2 == 0)
    neg.indx = which(Emax.vec2 < 0)
    if(length(zero.indx)>0)
        Emax.vec2[zero.indx] = 1
    if(length(neg.indx)>0)
        Emax.vec2[neg.indx] = 2^(Emax.vec2[neg.indx]) + 1
    return(Emax.vec2)

    # another possibililty
#   return(2^(Emax.vec))

    # another possibililty
#    transf = function(x){ neg.indxs=which(x<0); x[neg.indxs]=(-x[neg.indxs])^-1; x[which(x==0)]=1; return(x);}
#    return(transf(Emax.vec))
}




###########################################
# g: graph object
# A: adjacency matrix of the original graph
# v.ids : node ids of the same cluster (vertex ids start from 1 => for adjacency matrix)
# membership: partition
###########################################
compute.Emax.and.Sext = function(g, A, v.ids, membership){
#print("compute.Emax.and.Sext")

    Sext = rep(-Inf,length(v.ids))
    Emax = rep(-Inf,length(v.ids))
    Emax0 = rep(-Inf,length(v.ids))
    k = length(unique(membership))
    clu.id = membership[v.ids[1]+1]
    for(other.clu.id in seq(1,k)[-clu.id]){
        v.ext.indexs = which(membership == other.clu.id)
        v.ext.ids = as.integer(V(g)$name)[v.ext.indexs]

        curr.Emax = sapply(v.ids, function(v.id) sum(A[as.character(v.id),as.character(v.ext.ids)]))
        curr.Sext = sapply(v.ids, function(v.id) sum(abs(A[as.character(v.id),as.character(v.ext.ids)])))
        indx = which(Emax < curr.Emax)
        if(length(indx)>0) {
            Emax[indx] = curr.Emax[indx]
            Emax0[indx] = curr.Emax[indx]
            Sext[indx] = curr.Sext[indx]
        }
    }
    res = list()
    Emax = compute.mapping.for.external.coef(Emax)
    res[["Emax"]] = Emax
    res[["Emax0"]] = Emax0
    res[["Sext"]] = Sext   
    return(res)
}


###########################################
#
# OUTPUT
# ======
# possible values: 1, 2, 3 or 4
#   - choice 1: permanence model proposed by Li et al. 2016
#   - choice 2: adjusted permanence model with different mapping function (with penalization term) >> pow2 based
#   - choice 3: adjusted permanence model with different mapping function (with penalization term) >> transformation log10 based
#   - choice 4: different permanence model (without penalization term) >> a range of [0,1]
#
###########################################
compute.permanence.scores = function(g, A, membership){
    P.scores = rep(NA, vcount(g))
    my.P.scores1 = rep(NA, vcount(g))
    my.P.scores2 = rep(NA, vcount(g))
    my.P.scores3 = rep(NA, vcount(g))
    my.P.scores4 = rep(NA, vcount(g))

    cluster.sizes = table(membership)


    Cin = rep(NA, vcount(g))
    Emax = rep(NA, vcount(g))
    Emax0 = rep(NA, vcount(g)) # the same as I, but for the external cluster chosen by Emax
    I = rep(NA, vcount(g))
    D = rep(NA, vcount(g))
    k = length(unique(membership))
    for(clu.id in 1:k){
        # clust coef
        v.int.indexs = which(membership == clu.id)
        v.int.ids = as.integer(V(g)$name)[v.int.indexs]
        subg = induced_subgraph(g, v.int.indexs)
        subA = as_adjacency_matrix(subg, type="both",attr="weight")
        Cin[v.int.indexs] = sapply(v.int.ids, function(v.id) compute.signed.clu.coef.in.cluster(subA, v.id))

        # compute I: internal connections
        I[v.int.indexs] = sapply(v.int.ids, function(v.id) sum(subA[as.character(v.id), ]))

        # compute Emax and Sext: Emax is calculated from the cluster which has the max "pull off" among external clusters, Sext is strength of this cluster (i.e. degree ext)
        res = compute.Emax.and.Sext(g, A, v.int.ids, membership)
        Emax[v.int.indexs] = res[["Emax"]]
        Emax0[v.int.indexs] = res[["Emax0"]]

        # compute D: total interactions
        D[v.int.indexs] = sapply(v.int.ids, function(v.id) sum(abs(subA[as.character(v.id), ]))) + res[["Sext"]] # Sint + Sext

        part1.score = (I[v.int.indexs]/D[v.int.indexs])*(1/Emax[v.int.indexs]) # from article Li et al. "Community Detection in Complicated Network based on the Multi-view Weighted Signed Permanence"
        # part1.score = (I[v.int.indexs]+Emax[v.int.indexs])/(D[v.int.indexs]) # my estimation

        # deal with Nan values
        zero.indx = which(Emax[v.int.indexs] == 0)
        if(length(zero.indx)>0)
            part1.score[zero.indx] = 0
        penalization.term = (1-Cin[v.int.indexs]) # from article Li et al. "Community Detection in Complicated Network based on the Multi-view Weighted Signed Permanence"
        # penalization.term = 1-(1+Cin[v.int.indexs])/2 # my estimation
        if(cluster.sizes[clu.id]<6)
            penalization.term = 1

        P.scores[v.int.indexs] = part1.score - penalization.term

        transf = function(x){ neg.indxs=which(x<0); x[neg.indxs]=(-x[neg.indxs])^-1; x[which(x==0)]=1; return(x);}
        my.P.scores1[v.int.indexs] = (I[v.int.indexs]/D[v.int.indexs])*(1/transf(Emax[v.int.indexs])) - penalization.term

        my.P.scores2[v.int.indexs] = (I[v.int.indexs]-Emax0[v.int.indexs])/D[v.int.indexs] - penalization.term
        #my.P.scores2[v.int.indexs] = (I[v.int.indexs]-Emax0[v.int.indexs])/D[v.int.indexs] # in the end, a range of [0,1]

        #my.P.scores3[v.int.indexs] = Cin[v.int.indexs]

        #transf = function(x){ neg.indxs=which(x<0); x[neg.indxs]=(-x[neg.indxs])^-1; x[which(x==0)]=1; return(x);}
        #my.P.scores4[v.int.indexs] = transf(Emax0[v.int.indexs])

        #transf = function(x){ neg.indxs=which(x<0); x[neg.indxs]=(-x[neg.indxs])^-1; x[which(x==0)]=1; return(x);}
        #my.P.scores4[v.int.indexs] = (I[v.int.indexs]-transf(Emax0[v.int.indexs]))/D[v.int.indexs] - penalization.term
    }

    results = list()
    results[["1"]] = P.scores
    results[["2"]] = my.P.scores1
    results[["3"]] = my.P.scores2
    #results[["4"]] = my.P.scores3
    #results[["5"]] = my.P.scores4
    return(results)
}

# -----------------------------------------------------





if(FALSE){

membership.path = "membership21.txt"
membership = read.table(membership.path)$V1
network.path = "net.G"
g = read.graph.ils(network.path)
A = as_adjacency_matrix(g, type="both",attr="weight")
results = compute.permanence.scores(g, A, membership)
print(results[["1"]])
print("---")
print(results[["2"]])
print("---")
print(results[["3"]])
print("---")
print(results[["4"]])


print("---")
#res.kmeans = kmeans(x=P.scores, centers=2)
#print(P.scores[which(res.kmeans$cluster==1)])
#print(P.scores[which(res.kmeans$cluster==2)])

print("---")
#res.kmeans = kmeans(x=P.scores, centers=3)
#print(P.scores[which(res.kmeans$cluster==1)])
#print(P.scores[which(res.kmeans$cluster==2)])
#print(P.scores[which(res.kmeans$cluster==3)])


if(FALSE){
library(signnet)
E(g)$sign = E(g)$weight

print("---")
Pn.scores = pn_index(g)
print("pn scores")
print(Pn.scores)
print("!")
print(Pn.scores[c(5,7,8,13,16,30)])

print("---")
eigen.scores = eigen_centrality_signed(g)
print("eigen cores")
print(eigen.scores)
print("!")
print(eigen.scores[c(5,7,8,13,16,30)])
}

}
